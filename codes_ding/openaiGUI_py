import tkinter as tk
import open3d as o3d
import numpy as np
from tkinter import filedialog
import matplotlib.pyplot as plt
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from sympy import *
import ICP_utilities as uti
import os
import copy
import json
import sys
import math
# Erstelle das Hauptfenster
window = tk.Tk()
window.title("GUI")

# Setze die Fenstergröße auf 1200 * 1000
window.geometry("1200x1000")

# Setze die Dateipfad an 
model_path = None
mesh_path =None
source_path = None
registed_source = None
registed_target = None
finetuned_source = None
finetuned_target = None
finetuned_registed__both = None
# Definiere die Methode, die beim Klicken auf den Button ausgeführt wird
def pfad_auswahl():
    global model_path
    model_path = filedialog.askdirectory()
    print("Pfad wurde ausgewält")
    

def stl_auswahl():
    global mesh_path
    mesh_path = filedialog.askopenfilename(filetypes=[("stl Datei","*.stl")])
    print("stl datei wurde ausgewält")
    

def ply_auswahl():
    global source_path
    source_path = filedialog.askopenfilename(filetypes=[("ply Datei","*.ply"),("Alle Datei","*.*")])
    print("ply datei wurde ausgewält")

def ICP_steps():
    mesh = o3d.io.read_triangle_mesh(mesh_path)
    target = o3d.geometry.PointCloud(mesh.vertices)
    
    source = o3d.io.read_point_cloud(source_path)
    
    trans_init=[[1,0,0,0],
                [0,1,0,0],    
                [0,0,1,0],            
                [0,0,0,1],]

    num_iteration = 50
    threshold = 30
    threshold_calib = 0.01


    #down_sample_source = source.uniform_down_sample(every_k_points=3)
    registed_source,registed_target = uti.icp_algo_step_by_step(source=source, target=target, threshold=threshold, trans_init=trans_init,num_iteration=num_iteration)
       


def ICP_mit_finetuning():
    global registed_source
    global registed_target
    global finetuned_source
    global finetuned_target
    global finetuned_registed__both
    # target
    mesh = o3d.io.read_triangle_mesh(mesh_path)
    target = o3d.geometry.PointCloud(mesh.vertices)
    # source
    source = o3d.io.read_point_cloud(source_path)

    trans_init=[[1,0,0,0],
                [0,1,0,0],    
                [0,0,1,0],            
                [0,0,0,1],]

    num_iteration = 50
    threshold = 30
    threshold_calib = 0.01
    registed_source,registed_target = uti.icp_algo(source=source, target=target, threshold=threshold, trans_init=trans_init,max_iteration=num_iteration)
    v = tk.messagebox.askyesno(message="Wollen Sie Punktwolke speichern?")
    if v == True:
        save_path = filedialog.asksaveasfilename(filetypes=[("ply Datei","*.ply")],
                                                 defaultextension = ".ply")
        o3d.io.write_point_cloud(os.path.join(model_path,"registed_source.ply"),registed_source)
        o3d.io.write_point_cloud(os.path.join(model_path,"registed_target.ply"),registed_target)
        o3d.io.write_point_cloud(os.path.join(model_path,"registed__both.ply"),registed_source+registed_target)
        

    # finetuning:
    finetuning_process = tk.messagebox.askyesno(message="Führen Sie den Finetuning durch?")
    if finetuning_process == True:
        finetuned_source,finetuned_target = uti.calibration_after_rough_reg(source=registed_source,target=registed_target,threshold=threshold_calib,num_samples=int(input1.get()))
        o3d.io.write_point_cloud(os.path.join(model_path,"finetuned_source.ply"),finetuned_source)
        o3d.io.write_point_cloud(os.path.join(model_path,"finetuned_target.ply"),finetuned_target)
        finetuned_registed__both = finetuned_source+finetuned_target
        o3d.io.write_point_cloud(os.path.join(model_path,"finetuned_registed__both.ply"),finetuned_registed__both)
        print("finetuned Datein wurden in %s gespeichert"%(model_path))

def segmentation_kreis():
    
    print("Wählen Sie zuerst Mittelpunkt der Kreises und dann Radius (shift + left mouseclick)")
    example1 = o3d.io.read_point_cloud(os.path.join(model_path,"finetuned_registed__both.ply"))
    picked = uti.pick_points(example1)
    xyz_load = np.asarray(example1.points)
    x0 = round(xyz_load[picked[0]][0],2)
    y0 = round(xyz_load[picked[0]][1],2)
    x_edge = round(xyz_load[picked[1]][0],2)
    y_edge = round(xyz_load[picked[1]][1],2)
    r = math.sqrt((x0-x_edge)**2 + (y0-y_edge)**2)
    r = round(r,2)

    coord=[]
    for i in range(0,365,2):
        
        coord.append(round(r*math.cos(math.radians(i))+x0,2))
        coord.append(round(r*math.sin(math.radians(i))+y0,2)) 

    for j in range(2,len(coord)+183,3):
        coord.insert(j,0)

        j+=1

    arr = np.array(coord)
    new = np.reshape(arr, (-1,3))
    anew = np.float64(new)

    #json:
    json_path = os.path.join(model_path,"muster.json")
    json_path_out = os.path.join(model_path,"circle.json")
    dict1={}
    lis= anew.tolist()
    dict1 = uti.get_json_data(json_path, circle_coord=lis)
    uti.write_json_dict(json_path_out,dict1)

    cropped = uti.crop_from_json(example1, json_path_out)

    o3d.visualization.draw_geometries([cropped])
    #Punktwolke speichern
    v = tk.messagebox.askyesno(message="(Kreis) Punktwolke speichern?")
    if v == True:
        save_path = filedialog.asksaveasfilename(filetypes=[("ply Datei","*.ply")],
                                                 defaultextension = ".ply")
        o3d.io.write_point_cloud(save_path, cropped)  

def segmentation_ring():
    print("Wählen Sie zuerst Mittelpunkt der Kreises und dann innere/außere-Radius (shift + left mouseclick)")
    example1 = o3d.io.read_point_cloud(os.path.join(model_path,"finetuned_registed__both.ply"))
    
    picked = uti.pick_points(example1)
    print(picked)

    xyz_load = np.asarray(example1.points)
    #xyz=xyz_load[picked[0],picked[1]]
    print(xyz_load[picked[0]])
    print(xyz_load[picked[1]])
    print(xyz_load[picked[2]])

    x0 = round(xyz_load[picked[0]][0],2)
    y0 = round(xyz_load[picked[0]][1],2)

    x_edge = round(xyz_load[picked[1]][0],2)
    y_edge = round(xyz_load[picked[1]][1],2)

    x_outer = round(xyz_load[picked[2]][0],2)
    y_outer = round(xyz_load[picked[2]][1],2)

    r = math.sqrt((x0-x_edge)**2 + (y0-y_edge)**2)
    r_outer = math.sqrt((x0-x_outer)**2 + (y0-y_outer)**2)
    print(r)
    print(r_outer)
    r = round(r,2)
    r_outer = round(r_outer,2)
    coord=[]
    coord_outer=[]
    #####################
    for i in range(0,365,2):
        
        coord.append(round(r*math.cos(math.radians(i))+x0,2))
        coord.append(round(r*math.sin(math.radians(i))+y0,2))

    print(coord)    

    for j in range(2,len(coord)+183,3):
        coord.insert(j,0)

        j+=1
    print(coord)
    #####################
    for i in range(0,365,2):
        
        coord_outer.append(round(r_outer*math.cos(math.radians(i))+x0,2))
        coord_outer.append(round(r_outer*math.sin(math.radians(i))+y0,2))

    print(coord)    

    for j in range(2,len(coord_outer)+183,3):
        coord_outer.insert(j,0)

        j+=1
    print(coord_outer)
    #####################

    arr = np.array(coord)
    print(arr)
    arr_outer =np.array(coord_outer)
    print(arr_outer)

    new = np.reshape(arr, (-1,3))
    anew = np.float64(new)
    print(anew)

    new_outer = np.reshape(arr_outer, (-1,3))
    anew_outer = np.float64(new_outer)
    print(anew_outer)


    #gg=o3d.geometry.crop_point_cloud(example1,anew)
    #o3d.visualization.draw_geometries(gg)

    #json:
    json_path = os.path.join(model_path,"cropped_1.json")
    json_path_out = os.path.join(model_path,"ccc.json")
    json_path_out_outer = os.path.join(model_path,"ccc_outer.json")

    dict1={}
    dict1_outer={}

    lis= anew.tolist()
    lis_outer = anew_outer.tolist()

    dict1 = uti.get_json_data(json_path, circle_coord=lis)
    dict1_outer = uti.get_json_data(json_path, circle_coord=lis_outer)

    uti.write_json_dict(json_path_out,dict1)
    uti.write_json_dict(json_path_out_outer,dict1_outer)

    cropped = uti.crop_from_json(example1, json_path_out)
    cropped_outer = uti.crop_from_json(example1, json_path_out_outer)

    dis = cropped_outer.compute_point_cloud_distance(cropped)
    dis = np.asarray(dis)
    ind = np.where(dis>0.01)[0]
    ring = cropped_outer.select_by_index(ind)

    o3d.visualization.draw_geometries([ring]) 
    v = tk.messagebox.askyesno(message="(Ring) Punktwolke speichern?")
    if v == True:
        save_path = filedialog.asksaveasfilename(filetypes=[("ply Datei","*.ply")],
                                                 defaultextension = ".ply")
        o3d.io.write_point_cloud(save_path, ring)

label1 = tk.Label(window, text="Anzahl des Referenzpunkts:")
label2 = tk.Label(window, text="/")
label3 = tk.Label(window, text="/")
label4 = tk.Label(window, text="/")
label5 = tk.Label(window, text="/")
# Erstelle die Eingabefelder
input1 = tk.Entry(window)

# Erstelle die Schaltflächen
button1 = tk.Button(window, text="1.pfad_auswahl", command=pfad_auswahl)
button2 = tk.Button(window, text="2.stl_auswahl", command=stl_auswahl)
button3 = tk.Button(window, text="3.ply_auswahl", command=ply_auswahl)
button4 = tk.Button(window, text="4.ICP_mit_finetuning", command=ICP_mit_finetuning)
button5 = tk.Button(window, text="ICP_steps", command=ICP_steps)
button6 = tk.Button(window, text="5.segmentierung_kreis", command=segmentation_kreis)
button7 = tk.Button(window, text="segmentierung_ring", command=segmentation_ring)
# Platziere die Schaltflächen und Eingabefelder und labeln im Fenster
label1.place(relx=0.1, rely=0.25, anchor="c")
label2.place(relx=0.26, rely=0.28, anchor="c")
label3.place(relx=0.26, rely=0.33, anchor="c")
label4.place(relx=0.38, rely=0.33, anchor="c")

input1.place(relx=0.2, rely=0.25, anchor="c",width=50)

button1.place(relx=0.2, rely=0.1, anchor="c")
button2.place(relx=0.2, rely=0.15, anchor="c")
button3.place(relx=0.2, rely=0.2, anchor="c")
button4.place(relx=0.2, rely=0.28, anchor="c")
button5.place(relx=0.3, rely=0.28, anchor="c")
button6.place(relx=0.2, rely=0.33, anchor="c")
button7.place(relx=0.32, rely=0.33, anchor="c")
# Betrete die Meldungsschleife
window.mainloop()
